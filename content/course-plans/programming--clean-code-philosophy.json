{
  "categoryId": "programming",
  "subject": "Programming",
  "courseId": "programming--clean-code-philosophy",
  "courseTitle": "Clean Code Philosophy",
  "emoji": "âœ¨",
  "color": "#3B82F6",
  "requireAuthoredStory": true,
  "chapters": [
    { "id": "programming--clean-code-philosophy--ch01-why-clean-code-matters", "title": "Why Clean Code Matters", "position": 1 },
    { "id": "programming--clean-code-philosophy--ch02-naming-and-readability", "title": "Naming and Readability", "position": 2 },
    { "id": "programming--clean-code-philosophy--ch03-functions-and-structure", "title": "Functions and Structure", "position": 3 },
    { "id": "programming--clean-code-philosophy--ch04-design-principles", "title": "Design Principles", "position": 4 },
    { "id": "programming--clean-code-philosophy--ch05-managing-complexity", "title": "Managing Complexity", "position": 5 },
    { "id": "programming--clean-code-philosophy--ch06-refactoring-and-craft", "title": "Refactoring and Craft", "position": 6 }
  ],
  "topics": [
    {
      "chapter_id": "programming--clean-code-philosophy--ch01-why-clean-code-matters",
      "title": "What Clean Code Means",
      "story": {
        "hook": { "text": "Code is read ten times more often than it's written. Clean code optimizes for the reader.", "visual": "ğŸ“–" },
        "buildup": { "text": "Robert C. Martin defined clean code as code that reads like well-written prose.", "visual": "âœï¸" },
        "discovery": { "text": "Clean code does one thing well, has clear intent, and contains no surprises.", "visual": "âœ…" },
        "twist": { "text": "Writing clean code takes longer initially. But debugging messy code takes far longer.", "visual": "â³" },
        "climax": { "text": "Clean code isn't about beauty. It's about reducing the cost of change over time.", "visual": "ğŸ’°" },
        "punchline": { "text": "Write for the reader, not the compiler.", "visual": "ğŸ”‘" }
      },
      "quiz": {
        "question": "Who defined clean code as reading like well-written prose?",
        "options": ["Robert C. Martin", "Linus Torvalds", "Donald Knuth"],
        "correct": 0
      },
      "is_free": true
    },
    {
      "chapter_id": "programming--clean-code-philosophy--ch01-why-clean-code-matters",
      "title": "The Cost of Technical Debt",
      "story": {
        "hook": { "text": "Every shortcut in code is a loan. Technical debt charges compound interest.", "visual": "ğŸ’³" },
        "buildup": { "text": "Ward Cunningham coined the metaphor: messy code is like financial debt that slows future work.", "visual": "ğŸ¦" },
        "discovery": { "text": "Teams with high tech debt spend 40% of their time on unplanned rework instead of new features.", "visual": "ğŸ“Š" },
        "twist": { "text": "Some debt is strategic â€” shipping fast to learn. The mistake is never paying it back.", "visual": "ğŸ¯" },
        "climax": { "text": "Interest compounds. Code that was 'good enough' last year becomes next year's emergency.", "visual": "ğŸš¨" },
        "punchline": { "text": "Shortcuts today become slowdowns tomorrow.", "visual": "ğŸ”‘" }
      },
      "quiz": {
        "question": "Who coined the term 'technical debt'?",
        "options": ["Ward Cunningham", "Robert C. Martin", "Martin Fowler"],
        "correct": 0
      },
      "is_free": false
    },
    {
      "chapter_id": "programming--clean-code-philosophy--ch01-why-clean-code-matters",
      "title": "The Broken Windows Theory",
      "story": {
        "hook": { "text": "One broken window in a building signals neglect. Soon, every window gets smashed.", "visual": "ğŸªŸ" },
        "buildup": { "text": "In codebases, one messy function signals that sloppiness is acceptable. Others follow.", "visual": "ğŸ“‰" },
        "discovery": { "text": "The Pragmatic Programmer applied this theory to software: don't tolerate broken code.", "visual": "ğŸ“•" },
        "twist": { "text": "Fixing a small mess takes minutes. Cleaning up after years of neglect takes months.", "visual": "ğŸ§¹" },
        "climax": { "text": "Culture spreads through code. Leave it cleaner than you found it and quality compounds.", "visual": "âœ¨" },
        "punchline": { "text": "One broken window rots the whole codebase.", "visual": "ğŸ”‘" }
      },
      "quiz": {
        "question": "What book applied the broken windows theory to software?",
        "options": ["The Pragmatic Programmer", "Clean Code", "Design Patterns"],
        "correct": 0
      },
      "is_free": false
    },
    {
      "chapter_id": "programming--clean-code-philosophy--ch01-why-clean-code-matters",
      "title": "Code Smells",
      "story": {
        "hook": { "text": "You can't always prove code is bad, but you can smell it. Something just feels off.", "visual": "ğŸ‘ƒ" },
        "buildup": { "text": "Martin Fowler coined 'code smell' â€” surface signs that usually indicate deeper problems.", "visual": "ğŸ”" },
        "discovery": { "text": "Long methods, duplicated logic, and excessive comments are classic smells that signal trouble.", "visual": "âš ï¸" },
        "twist": { "text": "A smell isn't a bug. The code works fine. But it's harder to change, test, and understand.", "visual": "ğŸ§©" },
        "climax": { "text": "Learning to smell bad code is the first step. The fix is refactoring â€” restructuring without changing behavior.", "visual": "ğŸ”§" },
        "punchline": { "text": "If the code smells, it's time to clean up.", "visual": "ğŸ”‘" }
      },
      "quiz": {
        "question": "Who coined the term 'code smell'?",
        "options": ["Martin Fowler", "Robert C. Martin", "Kent Beck"],
        "correct": 0
      },
      "is_free": false
    },
    {
      "chapter_id": "programming--clean-code-philosophy--ch01-why-clean-code-matters",
      "title": "Reading Code Is Harder Than Writing It",
      "story": {
        "hook": { "text": "Joel Spolsky warned: never rewrite code from scratch. Reading old code just feels harder.", "visual": "ğŸ“œ" },
        "buildup": { "text": "Writing code feels creative. Reading someone else's code feels like deciphering a puzzle.", "visual": "ğŸ§©" },
        "discovery": { "text": "Studies show developers spend 60-70% of their time reading code, not writing it.", "visual": "ğŸ“Š" },
        "twist": { "text": "The temptation to rewrite comes from reading difficulty, not actual quality problems.", "visual": "ğŸ¤”" },
        "climax": { "text": "Clean code bridges this gap. When reading feels easy, teams move faster and rewrite less.", "visual": "ğŸš€" },
        "punchline": { "text": "Easy to read means easy to maintain.", "visual": "ğŸ”‘" }
      },
      "quiz": {
        "question": "What percentage of time do developers spend reading code?",
        "options": ["60-70%", "10-20%", "90-100%"],
        "correct": 0
      },
      "is_free": false
    },
    {
      "chapter_id": "programming--clean-code-philosophy--ch02-naming-and-readability",
      "title": "The Power of Good Names",
      "story": {
        "hook": { "text": "A variable called 'x' tells you nothing. A variable called 'userAge' tells you everything.", "visual": "ğŸ·ï¸" },
        "buildup": { "text": "Good names reveal intent. You should never need a comment to explain what a variable holds.", "visual": "ğŸ’¡" },
        "discovery": { "text": "Rename 'd' to 'elapsedDays' and suddenly the entire function makes sense without reading further.", "visual": "âœ¨" },
        "twist": { "text": "Naming is one of the two hardest problems in CS. Good names require deep understanding of the domain.", "visual": "ğŸ§ " },
        "climax": { "text": "A name that takes ten seconds longer to type saves ten minutes of confusion for every future reader.", "visual": "â±ï¸" },
        "punchline": { "text": "Name things so strangers understand instantly.", "visual": "ğŸ”‘" }
      },
      "quiz": {
        "question": "Why are good variable names important?",
        "options": ["They reveal intent without comments", "They make code run faster", "They reduce file size"],
        "correct": 0
      },
      "is_free": true
    },
    {
      "chapter_id": "programming--clean-code-philosophy--ch02-naming-and-readability",
      "title": "Avoiding Misleading Names",
      "story": {
        "hook": { "text": "A function called 'getData' that also deletes records is a trap waiting to spring.", "visual": "ğŸª¤" },
        "buildup": { "text": "Misleading names create false assumptions. Readers trust the name and skip reading the implementation.", "visual": "ğŸ™ˆ" },
        "discovery": { "text": "A name should be a contract. If it says 'get,' it should only retrieve. Nothing else.", "visual": "ğŸ“œ" },
        "twist": { "text": "Legacy codebases are full of functions whose names drifted from their behavior over years of edits.", "visual": "ğŸ“…" },
        "climax": { "text": "When behavior changes, the name must change too. A wrong name is worse than a bad name.", "visual": "âš–ï¸" },
        "punchline": { "text": "A misleading name is a bug in disguise.", "visual": "ğŸ”‘" }
      },
      "quiz": {
        "question": "What's worse than a bad variable name?",
        "options": ["A misleading name", "A short name", "A long name"],
        "correct": 0
      },
      "is_free": false
    },
    {
      "chapter_id": "programming--clean-code-philosophy--ch02-naming-and-readability",
      "title": "Comments Should Explain Why Not What",
      "story": {
        "hook": { "text": "A comment that says 'increment counter by one' above 'counter += 1' adds zero value.", "visual": "ğŸ“" },
        "buildup": { "text": "Comments that restate what the code does are noise. The code already says what it does.", "visual": "ğŸ”‡" },
        "discovery": { "text": "Useful comments explain why â€” the business reason, the regulatory constraint, the workaround.", "visual": "ğŸ’¡" },
        "twist": { "text": "Comments rot. Code changes but comments often don't, creating lies that mislead future readers.", "visual": "ğŸ¤¥" },
        "climax": { "text": "The best code needs almost no comments because the names and structure explain everything.", "visual": "âœ¨" },
        "punchline": { "text": "If you need a comment, the code isn't clear enough.", "visual": "ğŸ”‘" }
      },
      "quiz": {
        "question": "What should good comments explain?",
        "options": ["Why the code exists, not what it does", "Every single line of code", "The programming language syntax"],
        "correct": 0
      },
      "is_free": false
    },
    {
      "chapter_id": "programming--clean-code-philosophy--ch02-naming-and-readability",
      "title": "Consistent Formatting",
      "story": {
        "hook": { "text": "Tabs versus spaces sparked wars, but the real enemy is inconsistency.", "visual": "âš”ï¸" },
        "buildup": { "text": "Consistent formatting lets readers scan code without re-adjusting their mental model.", "visual": "ğŸ‘ï¸" },
        "discovery": { "text": "Teams that agree on one style and automate it spend zero time arguing about formatting.", "visual": "ğŸ¤–" },
        "twist": { "text": "It doesn't matter which style you pick. It matters that everyone uses the same one.", "visual": "ğŸ¤" },
        "climax": { "text": "Prettier, Black, and gofmt ended the debate. Let the tool decide and move on to real problems.", "visual": "ğŸ”§" },
        "punchline": { "text": "Pick a style. Automate it. Never debate again.", "visual": "ğŸ”‘" }
      },
      "quiz": {
        "question": "What is the best way to handle code formatting in a team?",
        "options": ["Agree on one style and automate it", "Let each person use their own style", "Use no formatting rules at all"],
        "correct": 0
      },
      "is_free": false
    },
    {
      "chapter_id": "programming--clean-code-philosophy--ch02-naming-and-readability",
      "title": "The Boy Scout Rule",
      "story": {
        "hook": { "text": "Leave the campground cleaner than you found it. Robert C. Martin applied this to code.", "visual": "ğŸ•ï¸" },
        "buildup": { "text": "Every time you touch a file, improve one small thing â€” rename a variable, extract a method.", "visual": "ğŸ§¹" },
        "discovery": { "text": "Over weeks, thousands of tiny improvements compound into a dramatically cleaner codebase.", "visual": "ğŸ“ˆ" },
        "twist": { "text": "No one has time for big cleanups. But everyone has time to fix one thing while they're already there.", "visual": "â±ï¸" },
        "climax": { "text": "Quality isn't a project. It's a habit applied one commit at a time.", "visual": "ğŸ”" },
        "punchline": { "text": "Leave every file a little better than you found it.", "visual": "ğŸ”‘" }
      },
      "quiz": {
        "question": "What does the Boy Scout Rule mean for code?",
        "options": ["Leave files cleaner than you found them", "Always rewrite from scratch", "Never change existing code"],
        "correct": 0
      },
      "is_free": false
    },
    {
      "chapter_id": "programming--clean-code-philosophy--ch03-functions-and-structure",
      "title": "Small Functions",
      "story": {
        "hook": { "text": "A 500-line function is not a function. It's a novel nobody wants to read.", "visual": "ğŸ“š" },
        "buildup": { "text": "Clean Code recommends functions be short â€” ideally under 20 lines, doing exactly one thing.", "visual": "ğŸ“" },
        "discovery": { "text": "Small functions are easy to name, easy to test, and easy to reuse across the codebase.", "visual": "ğŸ§©" },
        "twist": { "text": "Critics say too-small functions create indirection hell. Readers jump between dozens of files.", "visual": "ğŸ¤¯" },
        "climax": { "text": "The balance: small enough to understand at a glance, large enough to tell a complete story.", "visual": "âš–ï¸" },
        "punchline": { "text": "If a function needs a scroll bar, it's too long.", "visual": "ğŸ”‘" }
      },
      "quiz": {
        "question": "What does Clean Code recommend for function length?",
        "options": ["Short, ideally under 20 lines", "At least 100 lines for completeness", "Length doesn't matter"],
        "correct": 0
      },
      "is_free": true
    },
    {
      "chapter_id": "programming--clean-code-philosophy--ch03-functions-and-structure",
      "title": "Do One Thing",
      "story": {
        "hook": { "text": "A function called 'processOrder' that also sends emails and logs analytics is doing three things.", "visual": "3ï¸âƒ£" },
        "buildup": { "text": "The Single Responsibility Principle for functions: each function should do exactly one thing.", "visual": "1ï¸âƒ£" },
        "discovery": { "text": "If you can extract a meaningful sub-function, the original was doing more than one thing.", "visual": "âœ‚ï¸" },
        "twist": { "text": "Defining 'one thing' is the hard part. The right level of abstraction determines the boundary.", "visual": "ğŸ”" },
        "climax": { "text": "A function that does one thing can be described in a single sentence without the word 'and.'", "visual": "ğŸ“" },
        "punchline": { "text": "If you need the word 'and,' split it.", "visual": "ğŸ”‘" }
      },
      "quiz": {
        "question": "How can you tell a function does more than one thing?",
        "options": ["You can extract a meaningful sub-function", "It has more than five lines", "It uses two variables"],
        "correct": 0
      },
      "is_free": false
    },
    {
      "chapter_id": "programming--clean-code-philosophy--ch03-functions-and-structure",
      "title": "Function Arguments",
      "story": {
        "hook": { "text": "A function with seven arguments is a puzzle. Which value goes where?", "visual": "ğŸ§©" },
        "buildup": { "text": "The ideal number of function arguments is zero. Then one. Then two. Three is the maximum.", "visual": "ğŸ”¢" },
        "discovery": { "text": "Fewer arguments make functions easier to call, test, and understand at a glance.", "visual": "âœ…" },
        "twist": { "text": "If you need many arguments, they probably belong together as an object or configuration.", "visual": "ğŸ“¦" },
        "climax": { "text": "Boolean flags as arguments are a red flag. They mean the function does two different things.", "visual": "ğŸš©" },
        "punchline": { "text": "More arguments means more confusion.", "visual": "ğŸ”‘" }
      },
      "quiz": {
        "question": "Why are boolean flag arguments considered a code smell?",
        "options": ["They mean the function does two different things", "They make code run slower", "They use too much memory"],
        "correct": 0
      },
      "is_free": false
    },
    {
      "chapter_id": "programming--clean-code-philosophy--ch03-functions-and-structure",
      "title": "Error Handling",
      "story": {
        "hook": { "text": "Happy path code is easy. The real complexity lives in what happens when things go wrong.", "visual": "âš ï¸" },
        "buildup": { "text": "Returning error codes forces callers to check immediately. Miss one and bugs hide silently.", "visual": "ğŸ¤«" },
        "discovery": { "text": "Exceptions separate the happy path from error handling, keeping the main logic clean.", "visual": "ğŸ§¹" },
        "twist": { "text": "Catching too broadly swallows important errors. 'catch (Exception e)' hides real problems.", "visual": "ğŸ•³ï¸" },
        "climax": { "text": "Good error handling is specific, informative, and never silent. Fail loudly or fix quietly.", "visual": "ğŸ“¢" },
        "punchline": { "text": "Handle errors, don't hide them.", "visual": "ğŸ”‘" }
      },
      "quiz": {
        "question": "Why are exceptions preferred over error codes?",
        "options": ["They separate happy path from error handling", "They make code run faster", "They use less memory"],
        "correct": 0
      },
      "is_free": false
    },
    {
      "chapter_id": "programming--clean-code-philosophy--ch03-functions-and-structure",
      "title": "Avoiding Side Effects",
      "story": {
        "hook": { "text": "You call a function to check a password and it silently logs you out. That's a side effect.", "visual": "ğŸ˜±" },
        "buildup": { "text": "Side effects are hidden behaviors â€” changes to state that the caller doesn't expect.", "visual": "ğŸ­" },
        "discovery": { "text": "Pure functions take input and return output without modifying anything else. They're predictable.", "visual": "ğŸ”®" },
        "twist": { "text": "Real programs need side effects â€” writing to databases, sending emails. The trick is isolating them.", "visual": "ğŸ”¬" },
        "climax": { "text": "Push side effects to the edges of your code. Keep the core logic pure and testable.", "visual": "ğŸ§ª" },
        "punchline": { "text": "Predictable functions are trustworthy functions.", "visual": "ğŸ”‘" }
      },
      "quiz": {
        "question": "What is a pure function?",
        "options": ["One that returns output without modifying external state", "One that has no arguments", "One that runs the fastest"],
        "correct": 0
      },
      "is_free": false
    },
    {
      "chapter_id": "programming--clean-code-philosophy--ch04-design-principles",
      "title": "DRY â€” Don't Repeat Yourself",
      "story": {
        "hook": { "text": "The same validation logic appears in five different files. Change one and you'll forget the others.", "visual": "ğŸ“‹" },
        "buildup": { "text": "DRY says every piece of knowledge should exist in exactly one place in the codebase.", "visual": "1ï¸âƒ£" },
        "discovery": { "text": "Duplication isn't just copied text. It's duplicated knowledge â€” same rule, different expressions.", "visual": "ğŸ”" },
        "twist": { "text": "Over-applying DRY creates tight coupling. Sometimes two similar things should remain separate.", "visual": "ğŸ”—" },
        "climax": { "text": "The test: if the two pieces must always change together, merge them. If not, keep them apart.", "visual": "ğŸ§ª" },
        "punchline": { "text": "Duplicate knowledge rots. Duplicate code sometimes doesn't.", "visual": "ğŸ”‘" }
      },
      "quiz": {
        "question": "When should you NOT apply DRY?",
        "options": ["When similar code serves different purposes", "When the code is longer than ten lines", "When there are more than two duplicates"],
        "correct": 0
      },
      "is_free": true
    },
    {
      "chapter_id": "programming--clean-code-philosophy--ch04-design-principles",
      "title": "KISS â€” Keep It Simple",
      "story": {
        "hook": { "text": "A developer builds a microservice architecture for a to-do list app. Overkill kills.", "visual": "ğŸ”¨" },
        "buildup": { "text": "KISS says the simplest solution that works is almost always the best one.", "visual": "âœ¨" },
        "discovery": { "text": "Simple code has fewer bugs, is easier to test, and is faster to change when requirements shift.", "visual": "ğŸƒ" },
        "twist": { "text": "Simple doesn't mean easy. Finding the simplest solution often requires the deepest understanding.", "visual": "ğŸ§ " },
        "climax": { "text": "Cleverness is the enemy of maintainability. Write code a junior developer can understand.", "visual": "ğŸ‘¶" },
        "punchline": { "text": "Complexity is easy. Simplicity is the real skill.", "visual": "ğŸ”‘" }
      },
      "quiz": {
        "question": "What does the KISS principle recommend?",
        "options": ["The simplest working solution is usually best", "Use the most advanced patterns available", "Write as little code as possible"],
        "correct": 0
      },
      "is_free": false
    },
    {
      "chapter_id": "programming--clean-code-philosophy--ch04-design-principles",
      "title": "YAGNI â€” You Aren't Gonna Need It",
      "story": {
        "hook": { "text": "A developer adds a caching layer nobody asked for, 'just in case.' It breaks in production.", "visual": "ğŸ—ï¸" },
        "buildup": { "text": "YAGNI says don't build features until they're actually needed. Predicted needs are usually wrong.", "visual": "ğŸ”®" },
        "discovery": { "text": "Unneeded code still has to be maintained, tested, and understood by everyone who touches it.", "visual": "ğŸ§³" },
        "twist": { "text": "Engineers fear being unprepared. But unused abstractions cost more than building them later.", "visual": "ğŸ’°" },
        "climax": { "text": "Build what you need today. Refactor when requirements change. Most predicted needs never arrive.", "visual": "ğŸ“…" },
        "punchline": { "text": "The best code is the code you didn't write.", "visual": "ğŸ”‘" }
      },
      "quiz": {
        "question": "What does YAGNI stand for?",
        "options": ["You Aren't Gonna Need It", "You Always Get New Ideas", "Your Architecture Gets Neatly Integrated"],
        "correct": 0
      },
      "is_free": false
    },
    {
      "chapter_id": "programming--clean-code-philosophy--ch04-design-principles",
      "title": "The Single Responsibility Principle",
      "story": {
        "hook": { "text": "A class that handles user login, sends emails, and formats reports has three reasons to change.", "visual": "3ï¸âƒ£" },
        "buildup": { "text": "SRP says every module should have exactly one reason to change â€” one responsibility.", "visual": "1ï¸âƒ£" },
        "discovery": { "text": "When a class has one job, changes in one area don't ripple into unrelated behavior.", "visual": "ğŸ›¡ï¸" },
        "twist": { "text": "SRP doesn't mean one function per class. It means one axis of change per module.", "visual": "ğŸ“" },
        "climax": { "text": "Well-separated responsibilities make code modular, testable, and resilient to change.", "visual": "ğŸ§©" },
        "punchline": { "text": "One reason to change. One responsibility. One job.", "visual": "ğŸ”‘" }
      },
      "quiz": {
        "question": "What does the Single Responsibility Principle mean?",
        "options": ["Every module should have one reason to change", "Every function should be one line", "Every class needs one method"],
        "correct": 0
      },
      "is_free": false
    },
    {
      "chapter_id": "programming--clean-code-philosophy--ch04-design-principles",
      "title": "The Open-Closed Principle",
      "story": {
        "hook": { "text": "Adding a new payment method shouldn't require rewriting the entire checkout system.", "visual": "ğŸ’³" },
        "buildup": { "text": "The Open-Closed Principle says code should be open for extension but closed for modification.", "visual": "ğŸšª" },
        "discovery": { "text": "Well-designed systems let you add new behavior by adding new code, not changing existing code.", "visual": "â•" },
        "twist": { "text": "Achieving this requires forethought â€” interfaces, abstractions, and plugin architectures.", "visual": "ğŸ§ " },
        "climax": { "text": "The payoff is stability. Existing features don't break when new ones are added.", "visual": "ğŸ›¡ï¸" },
        "punchline": { "text": "Add new behavior without touching old code.", "visual": "ğŸ”‘" }
      },
      "quiz": {
        "question": "What does 'open for extension, closed for modification' mean?",
        "options": ["Add features by adding code, not changing existing code", "Never add new features", "Rewrite everything for each feature"],
        "correct": 0
      },
      "is_free": false
    },
    {
      "chapter_id": "programming--clean-code-philosophy--ch05-managing-complexity",
      "title": "Coupling and Cohesion",
      "story": {
        "hook": { "text": "Change one file and twenty others break. That's tight coupling strangling your codebase.", "visual": "ğŸ•¸ï¸" },
        "buildup": { "text": "Coupling measures how much modules depend on each other. Less coupling means easier changes.", "visual": "ğŸ”—" },
        "discovery": { "text": "Cohesion measures how well a module's internals belong together. High cohesion means focused code.", "visual": "ğŸ¯" },
        "twist": { "text": "You want low coupling between modules and high cohesion within them. Most codebases get both wrong.", "visual": "âŒ" },
        "climax": { "text": "The goal: change one module without the rest of the system knowing or caring.", "visual": "ğŸï¸" },
        "punchline": { "text": "Loosely connected. Tightly focused.", "visual": "ğŸ”‘" }
      },
      "quiz": {
        "question": "What is the ideal combination for code modules?",
        "options": ["Low coupling, high cohesion", "High coupling, low cohesion", "High coupling, high cohesion"],
        "correct": 0
      },
      "is_free": true
    },
    {
      "chapter_id": "programming--clean-code-philosophy--ch05-managing-complexity",
      "title": "Dependency Injection",
      "story": {
        "hook": { "text": "A class that creates its own database connection can never be tested without a real database.", "visual": "ğŸ”Œ" },
        "buildup": { "text": "Dependency injection means passing dependencies in from outside instead of creating them inside.", "visual": "ğŸ“¥" },
        "discovery": { "text": "Inject a fake database during tests, a real one in production. Same code, different behavior.", "visual": "ğŸ­" },
        "twist": { "text": "Over-injecting creates constructor chaos â€” classes with ten parameters nobody understands.", "visual": "ğŸ¤¯" },
        "climax": { "text": "Inject what changes. Hard-code what doesn't. Balance beats dogma.", "visual": "âš–ï¸" },
        "punchline": { "text": "Give objects what they need. Don't let them find it.", "visual": "ğŸ”‘" }
      },
      "quiz": {
        "question": "What problem does dependency injection solve?",
        "options": ["Hard-coded dependencies that prevent testing", "Slow code execution", "Memory leaks in applications"],
        "correct": 0
      },
      "is_free": false
    },
    {
      "chapter_id": "programming--clean-code-philosophy--ch05-managing-complexity",
      "title": "Composition Over Inheritance",
      "story": {
        "hook": { "text": "Inheritance creates rigid hierarchies. Change the parent and every child might break.", "visual": "ğŸŒ³" },
        "buildup": { "text": "A Dog extends Animal extends LivingThing. Three levels deep and you're already confused.", "visual": "ğŸ˜µ" },
        "discovery": { "text": "Composition assembles behavior from small, independent parts. Swap a part without rebuilding the whole.", "visual": "ğŸ§©" },
        "twist": { "text": "The Gang of Four said this in 1994. Thirty years later, developers still reach for inheritance first.", "visual": "ğŸ“…" },
        "climax": { "text": "Compose small, focused objects. Inherit only when there's a genuine is-a relationship.", "visual": "âœ…" },
        "punchline": { "text": "Build with Lego bricks, not family trees.", "visual": "ğŸ”‘" }
      },
      "quiz": {
        "question": "Why is composition preferred over inheritance?",
        "options": ["It creates more flexible, swappable behavior", "It runs faster at runtime", "It uses less memory"],
        "correct": 0
      },
      "is_free": false
    },
    {
      "chapter_id": "programming--clean-code-philosophy--ch05-managing-complexity",
      "title": "Encapsulation",
      "story": {
        "hook": { "text": "A class exposes all its internal variables. Any other code can change them without warning.", "visual": "ğŸ”“" },
        "buildup": { "text": "Encapsulation hides internal state and exposes only what's necessary through a controlled interface.", "visual": "ğŸ”" },
        "discovery": { "text": "When internals are hidden, you can change how a class works without affecting anything that uses it.", "visual": "ğŸ”§" },
        "twist": { "text": "Java's getter/setter pattern often fakes encapsulation. Exposing every field defeats the purpose.", "visual": "ğŸ­" },
        "climax": { "text": "True encapsulation means asking an object to do something, not reaching inside to do it yourself.", "visual": "ğŸ™" },
        "punchline": { "text": "Hide the details. Expose the intent.", "visual": "ğŸ”‘" }
      },
      "quiz": {
        "question": "What does encapsulation protect?",
        "options": ["Internal state from outside modification", "Code from being compiled", "Functions from being called"],
        "correct": 0
      },
      "is_free": false
    },
    {
      "chapter_id": "programming--clean-code-philosophy--ch05-managing-complexity",
      "title": "Law of Demeter",
      "story": {
        "hook": { "text": "user.getAddress().getCity().getZipCode() chains four objects. Change any one and the chain snaps.", "visual": "â›“ï¸" },
        "buildup": { "text": "The Law of Demeter says only talk to your immediate friends, not strangers down the chain.", "visual": "ğŸ¤" },
        "discovery": { "text": "Instead of reaching deep, ask the top object for what you need. Let it handle the delegation.", "visual": "ğŸ“¬" },
        "twist": { "text": "Following this strictly can create wrapper methods everywhere. Pragmatism matters.", "visual": "âš–ï¸" },
        "climax": { "text": "Short chains are resilient chains. Every dot in a chain is a dependency that might break.", "visual": "ğŸ’¥" },
        "punchline": { "text": "Don't talk to strangers. Talk to friends.", "visual": "ğŸ”‘" }
      },
      "quiz": {
        "question": "What does the Law of Demeter advise?",
        "options": ["Only interact with immediate dependencies", "Use as many objects as possible", "Chain methods for readability"],
        "correct": 0
      },
      "is_free": false
    },
    {
      "chapter_id": "programming--clean-code-philosophy--ch06-refactoring-and-craft",
      "title": "What Refactoring Really Means",
      "story": {
        "hook": { "text": "Refactoring is surgery on code â€” changing its structure without changing what it does.", "visual": "ğŸ”§" },
        "buildup": { "text": "Martin Fowler defined it as restructuring existing code to improve design while preserving behavior.", "visual": "ğŸ“˜" },
        "discovery": { "text": "Rename a variable, extract a method, split a class â€” each is a small, safe transformation.", "visual": "âœ‚ï¸" },
        "twist": { "text": "Without tests, refactoring is gambling. You can't confirm behavior is preserved if you can't test it.", "visual": "ğŸ²" },
        "climax": { "text": "Refactoring should be continuous â€” a daily habit, not a quarterly project.", "visual": "ğŸ“…" },
        "punchline": { "text": "Same behavior, better structure, every day.", "visual": "ğŸ”‘" }
      },
      "quiz": {
        "question": "What does refactoring preserve?",
        "options": ["External behavior while improving structure", "The original code exactly as written", "Only the comments and documentation"],
        "correct": 0
      },
      "is_free": true
    },
    {
      "chapter_id": "programming--clean-code-philosophy--ch06-refactoring-and-craft",
      "title": "Test-Driven Development",
      "story": {
        "hook": { "text": "Write the test before the code? That sounds backwards â€” until you try it.", "visual": "ğŸ”„" },
        "buildup": { "text": "TDD cycles through three steps: write a failing test, make it pass, then refactor.", "visual": "ğŸ”´" },
        "discovery": { "text": "Tests written first define what the code should do. The code exists only to satisfy the test.", "visual": "ğŸ“‹" },
        "twist": { "text": "TDD feels slow at first. But it catches bugs immediately and builds a safety net as you go.", "visual": "ğŸ•¸ï¸" },
        "climax": { "text": "With TDD, refactoring becomes fearless. Every change is verified by the existing test suite.", "visual": "ğŸ›¡ï¸" },
        "punchline": { "text": "Red, green, refactor â€” the rhythm of confident code.", "visual": "ğŸ”‘" }
      },
      "quiz": {
        "question": "What are the three steps of TDD?",
        "options": ["Write failing test, make it pass, refactor", "Write code, test it, deploy", "Design, implement, document"],
        "correct": 0
      },
      "is_free": false
    },
    {
      "chapter_id": "programming--clean-code-philosophy--ch06-refactoring-and-craft",
      "title": "Code Reviews as Teaching",
      "story": {
        "hook": { "text": "Code reviews aren't about catching mistakes. They're about spreading knowledge across the team.", "visual": "ğŸ“" },
        "buildup": { "text": "A reviewer sees patterns, alternatives, and risks the author missed while deep in the problem.", "visual": "ğŸ‘ï¸" },
        "discovery": { "text": "Junior developers learn faster from reviews than from any course. Real code, real feedback.", "visual": "ğŸ“ˆ" },
        "twist": { "text": "Harsh reviews shut people down. The best reviewers ask questions instead of giving orders.", "visual": "â“" },
        "climax": { "text": "Great review cultures produce great code. Toxic reviews produce fear and hidden shortcuts.", "visual": "ğŸŒ±" },
        "punchline": { "text": "Review the code, respect the person.", "visual": "ğŸ”‘" }
      },
      "quiz": {
        "question": "What is the primary value of code reviews?",
        "options": ["Spreading knowledge across the team", "Finding every single bug", "Proving who is the best coder"],
        "correct": 0
      },
      "is_free": false
    },
    {
      "chapter_id": "programming--clean-code-philosophy--ch06-refactoring-and-craft",
      "title": "Technical Excellence as a Habit",
      "story": {
        "hook": { "text": "Nobody plans to write bad code. It happens one small compromise at a time.", "visual": "ğŸ“‰" },
        "buildup": { "text": "Clean code is a discipline, not a talent. It requires deliberate practice every single day.", "visual": "ğŸ‹ï¸" },
        "discovery": { "text": "The Software Craftsmanship movement treats programming as a skill to be honed, not just a job.", "visual": "âš’ï¸" },
        "twist": { "text": "Perfection isn't the goal. Continuous improvement is. Today's code should be better than yesterday's.", "visual": "ğŸ“ˆ" },
        "climax": { "text": "The best codebases aren't written by geniuses. They're maintained by teams that care consistently.", "visual": "ğŸ¤" },
        "punchline": { "text": "Excellence isn't an act. It's a daily habit.", "visual": "ğŸ”‘" }
      },
      "quiz": {
        "question": "What does the Software Craftsmanship movement emphasize?",
        "options": ["Treating programming as a skill to be honed", "Writing code as fast as possible", "Using only the newest frameworks"],
        "correct": 0
      },
      "is_free": false
    },
    {
      "chapter_id": "programming--clean-code-philosophy--ch06-refactoring-and-craft",
      "title": "When Rules Should Be Broken",
      "story": {
        "hook": { "text": "Every principle in this course has exceptions. Blindly following rules creates its own mess.", "visual": "ğŸš§" },
        "buildup": { "text": "DRY can create coupling. YAGNI can prevent necessary preparation. SRP can over-fragment code.", "visual": "âš ï¸" },
        "discovery": { "text": "Principles are guides, not laws. The context â€” team size, deadline, system age â€” determines the choice.", "visual": "ğŸ§­" },
        "twist": { "text": "Dogmatic developers cause as much damage as careless ones. Rigid rules ignore real tradeoffs.", "visual": "âš–ï¸" },
        "climax": { "text": "Wisdom is knowing which rule to apply, which to bend, and which to ignore â€” right now.", "visual": "ğŸ§ " },
        "punchline": { "text": "Know the rules well enough to know when to break them.", "visual": "ğŸ”‘" }
      },
      "quiz": {
        "question": "When should clean code principles be broken?",
        "options": ["When context and tradeoffs demand it", "Never â€” rules are absolute", "Whenever it saves time"],
        "correct": 0
      },
      "is_free": false
    }
  ]
}
