{
  "id": "ai--rag-basics--t15-reranking",
  "version": 1,
  "subject": "AI",
  "subcategory": "RAG Basics",
  "course_id": "ai--rag-basics",
  "chapter_id": "ai--rag-basics--ch04-retrieval",
  "title": "Reranking",
  "emoji": "ğŸ”",
  "color": "#EF4444",
  "description": "Use a second model to refine the order of retrieved results.",
  "difficulty": "Advanced",
  "published": true,
  "story": {
    "hook": {
      "visual": "ğŸ†",
      "text": "Your vector search returns 20 chunks. The best answer is chunk #14. The LLM only sees the top 5. The answer is retrieved but never used."
    },
    "buildup": {
      "visual": "ğŸ”„",
      "text": "A reranker takes the initial retrieval results and re-scores them using a more powerful model that reads both the query and each chunk together."
    },
    "discovery": {
      "visual": "ğŸ’¡",
      "text": "Cross-encoder rerankers (like Cohere Rerank or BGE-reranker) compare query-chunk pairs with much higher accuracy than embedding similarity. They're slower but much more precise."
    },
    "twist": {
      "visual": "âš¡",
      "text": "Reranking only works on the initial result set. If the right chunk wasn't retrieved at all, reranking can't save you. Retrieve broadly (top 50), then rerank to top 5."
    },
    "climax": {
      "visual": "ğŸ",
      "text": "The pattern: fast initial retrieval (top 50 by vector similarity) â†’ slow reranking (top 5 by cross-encoder) â†’ inject top 5 into the prompt. This is production-grade RAG."
    },
    "punchline": {
      "visual": "ğŸ¬",
      "text": "Retrieve wide, rerank tight. Two stages beat one."
    }
  },
  "quiz": {
    "question": "Why should you retrieve more results than you need before reranking?",
    "options": [
      "To use more tokens",
      "To ensure the relevant chunk is in the initial set so the reranker can find it",
      "To slow down the system",
      "Reranking only works with exactly 50 results"
    ],
    "correct": 1
  }
}
