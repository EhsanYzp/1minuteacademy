{
  "id": "programming--the-history-of-programming-languages--t-why-new-languages-keep-appearing",
  "version": 1,
  "subject": "Programming",
  "subcategory": "The History of Programming Languages",
  "course_id": "programming--the-history-of-programming-languages",
  "chapter_id": "programming--the-history-of-programming-languages--ch06-modern-languages",
  "title": "Why New Languages Keep Appearing",
  "emoji": "ðŸ“œ",
  "color": "#3B82F6",
  "description": "A fast breakdown of Why New Languages Keep Appearing for builders.",
  "is_free": true,
  "published": true,
  "story": {
    "hook": {
      "text": "By 2010, programmers had hundreds of languages. Why would anyone create another one?",
      "visual": "ðŸ¤”"
    },
    "buildup": {
      "text": "Old languages carried decades of baggage â€” security holes, slow compilers, bloated syntax.",
      "visual": "ðŸ§³"
    },
    "discovery": {
      "text": "New hardware like multicore CPUs and cloud servers demanded languages built for concurrency.",
      "visual": "ðŸ”€"
    },
    "twist": {
      "text": "Most new languages fail. Developers resist switching because existing tools already work.",
      "visual": "ðŸš§"
    },
    "climax": {
      "text": "The winners solve one painful problem so well that the switching cost becomes worth it.",
      "visual": "ðŸŽ¯"
    },
    "punchline": {
      "text": "New languages survive by solving old pain.",
      "visual": "ðŸ”‘"
    }
  },
  "quiz": {
    "question": "Why do most new programming languages fail?",
    "options": [
      "Developers resist switching from working tools",
      "They are always slower",
      "Governments ban them"
    ],
    "correct": 0
  }
}
