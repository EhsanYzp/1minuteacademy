{
  "id": "programming--evolution-of-software-engineering--t-requirements-engineering",
  "version": 1,
  "subject": "Programming",
  "subcategory": "Evolution of Software Engineering",
  "course_id": "programming--evolution-of-software-engineering",
  "chapter_id": "programming--evolution-of-software-engineering--ch02-the-waterfall-era",
  "title": "Requirements Engineering",
  "emoji": "ğŸ—ï¸",
  "color": "#3B82F6",
  "description": "A quick win: understand Requirements Engineering.",
  "is_free": false,
  "published": true,
  "story": {
    "hook": {
      "text": "Ask the customer what they want. Write it down. Build it. They say 'that's not what I meant.'",
      "visual": "ğŸ˜©"
    },
    "buildup": {
      "text": "Waterfall demanded complete requirements upfront â€” every feature specified before a line of code.",
      "visual": "ğŸ“"
    },
    "discovery": {
      "text": "Detailed specs gave everyone a shared blueprint and reduced ambiguity in large government contracts.",
      "visual": "ğŸ›ï¸"
    },
    "twist": {
      "text": "Requirements change. Markets shift. By the time you finish building, the customer wants something else.",
      "visual": "ğŸ”„"
    },
    "climax": {
      "text": "The requirements problem taught us that software is discovered, not just specified.",
      "visual": "ğŸ”"
    },
    "punchline": {
      "text": "What customers want changes faster than you can write it down.",
      "visual": "ğŸ”‘"
    }
  },
  "quiz": {
    "question": "Why do upfront requirements often fail?",
    "options": [
      "Customer needs change during development",
      "Developers don't read them",
      "They are always too short"
    ],
    "correct": 0
  }
}
