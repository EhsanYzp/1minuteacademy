{
  "id": "programming--evolution-of-software-engineering--t-performance-testing",
  "version": 1,
  "subject": "Programming",
  "subcategory": "Evolution of Software Engineering",
  "course_id": "programming--evolution-of-software-engineering",
  "chapter_id": "programming--evolution-of-software-engineering--ch05-quality-practices",
  "title": "Performance Testing",
  "emoji": "ğŸ—ï¸",
  "color": "#3B82F6",
  "description": "A short lesson to help you apply Performance Testing.",
  "is_free": false,
  "published": true,
  "story": {
    "hook": {
      "text": "Your app works fine with ten users. Then a thousand log in at once and the server melts.",
      "visual": "ğŸ”¥"
    },
    "buildup": {
      "text": "Performance testing simulates real load to find bottlenecks before actual users experience them.",
      "visual": "ğŸ“ˆ"
    },
    "discovery": {
      "text": "Load tests reveal database queries that scale badly, memory leaks, and thread contention problems.",
      "visual": "ğŸ”¬"
    },
    "twist": {
      "text": "Most teams skip performance testing until launch day. By then, the architecture is too rigid to fix.",
      "visual": "ğŸ—ï¸"
    },
    "climax": {
      "text": "Testing under load early saves midnight firefighting later. Know your limits before users find them.",
      "visual": "ğŸš’"
    },
    "punchline": {
      "text": "Test at scale before your users do it for you.",
      "visual": "ğŸ”‘"
    }
  },
  "quiz": {
    "question": "When should performance testing happen?",
    "options": [
      "Early and continuously, before launch",
      "Only after users complain",
      "Never â€” hardware will handle it"
    ],
    "correct": 0
  }
}
